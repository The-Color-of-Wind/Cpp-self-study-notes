c++ prime 读书笔记

第一章 开始
1、main函数返回类型必须是int

2、endl
    endl作用：结束当前行，并将与设备关联的缓冲区中的内容刷到设备中
    缓冲刷新操作：可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流

    注：调试时常添加打印语句，这类语句应该保证“一直”刷新流。
        否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误判断。



第二章 变量和基本类型
一、 基本内置类型
1、如果两个字符串字面值中间只由空格、缩进和换行符间隔，实际是一个整体
        cout << "a b cin"  "def \a" << endl;

2、字符串里，“ \x后加数字，相当于16进制（超过会报错）     \后加1或2或3个数字相当于8进制（超过三个就不管） ”

3、 指定字面值类型（加前缀或后缀）
如：L'a'(宽字符wchar_t类型),  u8"hi!", 42ULL
	cout << sizeof("a") << endl;
	cout << sizeof(L"a") << endl;
    结果 2 4      
    
    "aa"  L"aa"    
    结果  3  6

    cout << sizeof('a') << endl;
    cout << sizeof(L'a') << endl;
    结果1  2

二、变量
1、列表初始化
    int a = 0;
    int a = {0};
    int a{0};
    int a(0);
    都是初始化a=0；
    
    其中a = {0};     a{0};    花括号代表列表初始化
    列表初始化是如果存在丢失信息的风险，则列表初始化报错
    如：
        long double b = 3.1415926536;
        int a{b}, c = {b};  //报错，存在丢失信息的风险
        int d(b), f = b;    //正确，并且确实丢失了部分值

2、默认初始化
    函数体之外定义变量 默认初始化为0；
    函数体内不被初始化，无法调用

    每个类决定自己初始化对象的方式

3、extern
    分离式编译机制：允许将程序分割成若干个文件，每个文件可被独立编译。
    声明：
    如果声明变量而非定义，则变量名前加关键字extern：
        extern int i;
    其中：
        在外部，可以给由extern关键字标记的变量赋一个初始值，extern int i= 0；
    但此行为抵消了extern的作用。
        在整数体内部，不能初始化由extern关键字标记的变量。

    总结：变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，但绝对不能重复定义。
    
    c++是一个静态类型的语言，含义是在编译阶段检查类型

4、允许内层作用域重新定义外层作用域已有的名字。
    int r = 42;
    int main(int argc, const char * argv[])
    {
	    cout << r << endl;
	    int r = 0;	
	    cout << r << endl;
	    cout << ::r << endl;
	    return 0;
    }
    输出：  42
            0
            42

三、复合类型
1、引用
    1、引用必须被初始化
    2、引用的类型必须与其所引用对象的类型一致
    3、引用初始化后不可更改
    例外：
        1、初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
        int i = 42;
	    const int &r1 = i;  //允许将const int&绑定到一个普通的int对象上
        （i值可以改变，但不能通过r1改变i的值）
        const int &r2 = 42; //正确：r2是一个常量引用
        const int &r3 = r1 * 2; //正确：r3是一个常量引用
      × int &r4 = r1 * 2; //错误：r4是一个普通的非常量引用


2、指向指针的引用
    int i = 42;
    int *p = null;  //int型指针
    int *&r = p;    //指针型引用，引用p
    r = &i;         //r就是指针p的别名，==== p指向i的地址
    *r = 0；        //*r 就是 *p 就是p指向地址的值 ===== i=0


四、const限定符
    1、const对象必须初始化： 
        const int i = get_size();  //运行时初始化
        const int i = 45;           //编译时初始化
        const int i;  //错误！！
    2、const引用：
        必须定义const类型的引用

    3、初始化对const的引用
        int i = 42;
	    int &r1 = i;
      × int &r2 = r1 * 2; //变量引用绑定在 临时量  不合法

	    const int &c2 = r1 * 2;  ////常量引用绑定在 临时量  合法

        引用总结：
            1、普通引用
                不能引用常量，数值
                不能引用临时量
                可以通过引用改变引用对象的值
            2、对常量的引用：（也可以称为：常量引用）
                可以引用常量、变量，不能引用数值
                可以引用临时量
                不能通过引用改变引用对象的值
            

    4、指向常量的指针：const double *cptr=&pi   跟常量引用类似
        const double pi = 3.14; //pi 是一个常量，它的值不能改变
	  × double *ptr = &pi;   //错误， double类型的指针不能指向常量；
	    const double *cptr = &pi;  //指向常量的指针可以指向常量
	  × *cptr = 42;  //错误，不能给*cptr赋值

	    double dval = 3.14;
	    cptr = &dval;   //指向常量的指针可以改变指针位置
	  × *cptr = 42;   //同样不能通过*cptr（指向常量的指针）来改变

	注：指向常量的指针，就默认为自己指向了常量，故不可通过指针来改变所指对象的值


    5、常量指针：int *const xx=xxx；  （常量指针指向的地址不能改变，是否能通过指针改变该地址的数据，取决于指向的数据类型） 
        指向的变量必须定义在函数体之外（暂不知为何）

    总结：
        指向常量的指针：
            1、必须初始化
            2、可以指向常量、变量
            3、指针指向的地址可以改变，指向其他对象
            4、自认为指向的都是常量，都不可以通过指针改变对象的值
        常量指针：
            1、必须初始化
            2、不可以指向常量（指针是常量）
            3、指针指向的地址赋值后不可以改变
            4、可以通过指针改变指向对象的值
        指向常量的常量指针：
            1、必须初始化
            2、可以指向常量、变量
            3、指针指向的对象不能改变
            4、不可以通过指针改变指向对象的值

    6、顶层const：任意对象本身是常量
       底层const：指针和引用等复合类型，指向或引用的对象是一个常量

    7、constexpr和常量表达式：
        常量表达式：编译过程就能得到计算结果的表达式
        如果是常量表达式，则定义：
            constexpr int mf = 20;
            constexpr int limit = mf+1;
            constexpr int sz = size();   //只有size()是一个constexpr函数时才正确
        
    8、字面值类型：
        算术类型、引用和指针都是（其他后续学习再加）
        自定义的类、IO库、string类  不属于字面值类型
    
    9、constexpr指针    
        constexpr指针的初始值必须时nullptr或0，或存储于某个固定地址中的对象
            函数体内定义的变量一般来说并非存放在固定地址中
            定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针
            允许函数定义一类有效范围超出函数本身的变量
        constexpr引用也绑定这样的变量上

        const int *p = nullptr;     //指向整型常量的指针
        constexpr int *q = nullptr; //指向整数的常量指针（constexpr把它所定义的对象置为了顶层const）

        意义：constexpr会在编译期就计算完该值,从而提高了性能

五、处理类型
    1、类型别名
        typedef double wages;   //wages 是double的同义词
        typedef wages base, *p; //base 是double的同义词， p 是 double* 的同义词

    2、复合类型、常量、auto
            int i = 0, &r = i;
            auto a = r;     //a是一个整数（r是i的别名）

        auto一般忽略顶层const，保留底层const
            const int ci = i, &cr = ci;
            auto b = ci;    //b是int（有顶层const：对象本身是const，忽略顶层const）
            auto c = cr;    //c是int（cr是ci的别名，同上）
            auto d = &i;    //d是int *（i是int型）
            auto e = &ci;   //e是const int *  指向常量的指针（&ci是对常量ci取地址，是一种底层const）

        如果想要推断出auto类型是一个顶层const，则需明确指出：
            const auto f = ci;  //ci推断是int， f是const int

        引用的类型也可以设为auto，原来初始化规则仍适用：
            auto &g = ci;   //g是const int & ，绑定到ci（引用后相当于存在底层const）
          × auto &h = 42;   //引用不能绑定字面值
            const auto &j = 42; //正确，const引用可以绑定字面值

    3、decltype类型指示符
        希望从表达式的类型推断出要定义的变量的类型
        decltype(xxx) a;    //xxx是表达式（变量也算一种表达式）
        
        decltype推断的类型包括顶层const和引用
            const int ci = 0, &cj = ci;
            decltype(ci) x = 0; //x类型是整形常量  const int
          × decltype(ci) x1;    //x1是整形常量，必须初始化
            decltype(cj) y = x; //y类型是 const int &
          × decltype(cj) y1;    //y1是引用，必须初始化
            
        decltype的结果类型跟表达式形式密切相关    
            decltype(cj+1) y1;  //正确，y1是int型（cj+1相当于ci+1）
        
        如果表达式的内容时解引用，则decltype将得到引用类型
            int i = 12, *p = &i, &r = i;
          × decltype(*p) c;     //*p代表解引用，得到是引用类型
        
        表达式如果加上了括号（注意是双层括号），结果永远是引用
            decltype (i) d;     //d是未初始化的int型
          × decltype ( (i) ) e; //e是int &  引用类型必须初始化

        赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型
            int a = 0, b = 0;
            decltype(a = b) d = a;
            decltype()里的表达式不运算
    
    4、头文件
        头文件通常包含只能被定义一次的实体，如类、const、constexpr变量等
        也经常遇到其他头文件的功能，如string.h头文件

    5、预处理器：在编译之前执行的一段程序，可以部分地改变我们所写地程序
    6、预处理变量（如NULL）：由预处理器管理的变量。在程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实值。
        不属于命名空间std，它由预处理器负责管理
        无视C++语言中关于作用域的规则


第三章 字符串、向量和数组
一、string
    1、最后都有一个空字符'\0'
    2、忽略前面的空白，以空白结尾（包括空格）


第四章 表达式
    1、一元运算符（作用于一个运算对象）：如&，*
       二元运算符（作用于两个运算对象）：
       函数调用也是一种特殊的运算符，它对运算对象的数量没有限制
    
    2、c++表达式要么是右值，要么是左值
        右值：当一个对象被用作右值的时候，用的是对象的值（内容）
        左值：当一个对象被用作左值的时候，用的是对象的身份（位置）
        在需要右值的地方可以用左值代替，但不能将右值当作左值（也就是位置）使用

    3、bool类型运算实际上就是转换成01运算

    4、除法运算：如果两个运算符号相同，则结果为正，不同则为负；结果一律向0取整
    5、取余运算：结果的正负跟第一个数一样

    6、如果比较的类型不是bool类型，则不要直接跟bool比较
        int a = 2;
        if(a == true){}  //相当于比较 a == 1

    7、赋值运算符满足右结合律：a=b=1; 从右往左赋值
    8、0可以赋值给指针，int *a = 0; ==== int *a = NULL;

    9、非必要不要写后置版本：i++，要写++i，减少不必要的开销，避免麻烦。
    10、后置递增运算符的优先级高于解引用运算符
    11、解引用运算符的优先级低于点运算符：*p.size();    //错误，p是一个指针，它没有名为size的成员
                                      (*p).size();   //正确，*p, 是解引用，是一个对象

    12、条件运算符：cond ？expr1:expr2
        可以嵌套string s = (a < 20) ? "a<20"
		                            : (a > 5) ? "a>5" : "a < 5";
        输出表达式中要加括号cout << ((a < 20) ? "a<20" : "aaa");

    13、位运算符：
        运算对象是"小整数"，则它的值会自动提升成较大的整数类型
        注：位运算对于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。
    14、移位运算符（IO运算符）满足做结合律
        cout<<"a"<<"b"<<"c";
    ====((cout<<"a")<<"b")<<"c";
        优先级比算术低，比关系运算符、赋值、条件运算符高

    15、sizeof运算符：sizeof(type)  sizeof expr
        1、sizeof运算符满足右结合律
        2、sizeof优先级和*一样，且右结合，所以sizeof *p = sizeof (*p)
        3、在sizeof的运算对象中，解引用一个无效指针仍然是一种安全的行为，因为不需真的解引用也能知道它所指对象的类型（试了一下，全是4）
        运算结果依赖其作用的类型：
            char    返回1
            引用    返回引用对象所占空间
            指针    返回指针所占空间（本人电脑都是4）
            对解引用指针    返回指针指向的对象所占空间的大小，指针不需要有效
            数组    整个数组所占空间的大小，sizeof不会把数组换成指针来处理
            string(试的都是28)和vector（试了几次，16）  只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间

    16、逗号运算符：从左到右依次计算，以最后一个表达式的值作为整体表达式的值
            int a1 = 1, a2 = 2, a3 = 3, a;
            a = (a1, a2, a1 + a2);      //a=3
	        a = (a1, --a2, a1 + a2);    //a=2
            a = (a1++, --a2, a1 + a2);  //a=3

            int b = a1++, d = a1;       //b=3, d=4

    17、算数转换：小转大（尽可能保留信息）
        有符号转无符号（有符号范围不能包含无符号）
            unsigned int u = 2;
	        int u1 = -5;
            u+u1;  //无符号
        无符号转有符号（有符号范围能包含无符号）
            unsigned int u = 2;
	        double u1 = -5;
            u+u1;  //有符号




第六章 函数
一、基础    
    1、通过调用运算符（ 形式是函数后的() ）来执行函数。它作用于一个表达式，该表达式是函数或者指向函数的指针
    2、执行函数的第一步是（隐式的）定义并初始化它的形参
        例：void fun(int a)
        {
            a = 5; return;
        }
        调用时：fun(10)   等价于  int a = 10; a=5; return;
    3、函数最外层作用域中的局部变量不能使用与函数形参一样的名字
    4、函数返回类型不能是数组类型或函数类型

    5、局部对象：
        自动对象：只存在于块执行期间的对象（如形参）
        局部静态对象：默认初始化为0（字符串默认是空字符）
    
    6、函数声明也称作函数原型
    7、函数声明不包含函数体，所以也无须形参的名字；

    8、分离式编译，书187页

    9、数组形参：
        1、不允许拷贝数组，使用数组时（通常）会将其转换成指针
        2、void print(int *)
           void print(int[])
           void print(int[10])
           这三个形式等价，都等同于传入int *类型
           调用print(arr)，实参自动地转换成指向数组首元素地指针

        3、（我的）不允许使用引用的数组 int &a[2] (个人猜测待考察：引用必须初始化，数组没办法所有元素同一时间初始化)
            void print( int (&a)[2] ) 数组的引用可以当参数，但是大小必须一样[2]  

        4、传多维数组：
            void print(int (*arr)[10] );
            void print(int arr[][10] );  编译器一如既往的忽略掉第一个维度，最后不要把它包括在形参列表内，不影响）

        5、main：处理命令行选项，书197页
    
    10、可变形参：
        1、initializer_list形参（就是列表）
            void error_msg(initializer_list<string> il)
            {
	             for (auto beg = il.begin(); beg != il.end(); ++beg)
		            cout << *beg << " ";
             	cout << endl;
            }
            main()
            {
                string a = "aaa", b = "aaa";
	            if (a != b)
	            {
		           error_msg({ "fun", "aaa", "bbb" });
	            }
	            else
		            error_msg({ "aaa", "bbb" });
            }
        2、省略符形参：void foo(int a, ...)  或 void foo(...) 
            省略符形参只能出现在形参列表的最后一个位置
            为了便于C++程序访问某些特殊的C代码而设置的
            应该仅仅用于C和C++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝

            void foo(int a, ...)
            {
    	        va_list ap;		

    	        __crt_va_start(ap, a);
    	        char* b = __crt_va_arg(ap, char*);
	            double c = __crt_va_arg(ap, double);
	            char* d = __crt_va_arg(ap, char*);
	            __crt_va_end(ap);

	            printf("%d,%s,%f,%s", a, b, c, d);
            //	cout << a << *b << c << *d << endl;		//char *a 只输出第一个字符
	            return;
            }
            测试：
                foo(10, "aaa", 12.25, "bbb");















第十四章 重载运算与类型转换
1、重载输出运算符
    1、输入输出运算符必须是非成员函数。否则，运算符左侧运算对象将是类中一个对象，并且该对象必须是istream或ostream成员，但该标准库不能添加任何成员
    












零散知识点：
1、void*  不能执行解引用操作
2、“[]”的优先级比“*”的高，[]的优先级为1，*的优先级为2。且优先级：()>[]>*