

## 第二题：
### 思路：
排除“/”和“.”， 随后取出//之间的字符串，整体进行判断进出栈


```C++
class Solution {
public:
    string simplifyPath(string path) {
        vector<string> pathVector;
        int i = 0;
        while (i < path.size()) {
            while (i < path.size() && path[i] == '/')
                ++i;
            if (i == path.size())
                break;
            int j = i;
            while (j < path.size() && path[j] != '/')
                j++;
            string str = path.substr(i, j - i);
            if (str != "."){
                if (str == ".." && !pathVector.empty()) {
                    pathVector.pop_back();
                }
                else if(str != ".."){
                    pathVector.push_back(str);
                }
            }
            i = j;
        }

        string ss;
        for (int i = 0; i < pathVector.size(); i++) {
            ss = ss + '/' + pathVector[i];
        }
        if (ss == "")
            return "/";
        return ss;
    }
};

```

## 第三题：最小栈（中等）
### 思路：
用一个辅助栈，每次压栈时都在辅助栈压一个min(当前栈, 入栈数据)，这样就能保证最小值在辅助栈和数据栈能同步进出
```
C++
class MinStack {
public:
    stack<int> myStack;
    stack<int> stackMin;

    MinStack() {
        stackMin.push(INT_MAX);
    }

    void push(int val) {
        myStack.push(val);
        stackMin.push(min(stackMin.top(), val));
    }

    void pop() {
        stackMin.pop();
        myStack.pop();
    }

    int top() {
        return myStack.top();
    }

    int getMin() {
        return stackMin.top();
    }
};

```
