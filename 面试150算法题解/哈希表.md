## 第一题：赎金信（简单）
### 本人思路，先排序，再依次查找（速度慢，内存小）
```C++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        sort(ransomNote.begin(), ransomNote.end());
        sort(magazine.begin(), magazine.end());
        int i = 0;
        for (int j = 0; j < magazine.size(); j++) {
            if (i < ransomNote.size() && ransomNote[i] == magazine[j]) {
                i++;
            }
        }
        return i >= ransomNote.size();
    }
};
```
### 题解：通过vector存储字母数量进行比较
```C++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        if (ransomNote.size() > magazine.size()) {
            return false;
        }
        vector<int> cnt(26);
        for (auto& c : magazine) {
            cnt[c - 'a']++;
        }
        for (auto& c : ransomNote) {
            cnt[c - 'a']--;
            if (cnt[c - 'a'] < 0)
                return false;
        }
        return true;
    }
};
```

## 第二题：同构字符串
### 本人思路：
两个unordered_map相互保存两个字符串的对应关系，判断是否相同
```C++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map<char, char> sMap;
        unordered_map<char, char> tMap;

        for (int i = 0; i < s.size(); i++) {
            auto sit = sMap.find(s[i]);
            auto tit = tMap.find(t[i]);
            if (sit == sMap.end() && tit == tMap.end()){
                sMap.insert({ s[i], t[i] });
                tMap.insert({ t[i], s[i] });
            }
            else {
                if (sit == sMap.end() || tit == tMap.end()) {
                    return false;
                }
                if (sit->second == t[i] && tit->second == s[i])
                    continue;
                else
                    return false;

            }
        }
        return true;
    }
};
```
### 题解：
思路一致，所用的map内部方法比我更优越
```C++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map<char, char> sMap;
        unordered_map<char, char> tMap;

        for (int i = 0; i < s.size(); i++) {

            if (( sMap.count(s[i]) && sMap[s[i]] != t[i] ) || ( tMap.count(t[i]) && tMap[t[i]] != s[i] ))
                return false;
            sMap[s[i]] = t[i];
            tMap[t[i]] = s[i];
        }
        return true;
    }
};

```
### 知识点：

1、map.cout(i)，判断i键是否存在；

2、auto it = map.find(i),查找i键并返回其值（it->second）

3、s[i];若i键存在，取出对应的值、若不存在，则自动插入i，并设为初始值；
